// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: connector.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// sets the .proto file syntax version

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Border0_V1_Action: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case create // = 0
  case update // = 1
  case delete // = 2
  case other // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .create
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .create
    case 1: self = .update
    case 2: self = .delete
    case 3: self = .other
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .create: return 0
    case .update: return 1
    case .delete: return 2
    case .other: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Border0_V1_Action] = [
    .create,
    .update,
    .delete,
    .other,
  ]

}

struct Border0_V1_ControlStreamRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestType: Border0_V1_ControlStreamRequest.OneOf_RequestType? = nil

  var config: Border0_V1_Config {
    get {
      if case .config(let v)? = requestType {return v}
      return Border0_V1_Config()
    }
    set {requestType = .config(newValue)}
  }

  var heartbeat: Border0_Common_V1_HeartbeatMessage {
    get {
      if case .heartbeat(let v)? = requestType {return v}
      return Border0_Common_V1_HeartbeatMessage()
    }
    set {requestType = .heartbeat(newValue)}
  }

  var pluginDiscoveryResults: Border0_V1_PluginDiscoveryResults {
    get {
      if case .pluginDiscoveryResults(let v)? = requestType {return v}
      return Border0_V1_PluginDiscoveryResults()
    }
    set {requestType = .pluginDiscoveryResults(newValue)}
  }

  var tunnelCertificateSignRequest: Border0_V1_TunnelCertificateSignRequest {
    get {
      if case .tunnelCertificateSignRequest(let v)? = requestType {return v}
      return Border0_V1_TunnelCertificateSignRequest()
    }
    set {requestType = .tunnelCertificateSignRequest(newValue)}
  }

  var log: Border0_V1_Log {
    get {
      if case .log(let v)? = requestType {return v}
      return Border0_V1_Log()
    }
    set {requestType = .log(newValue)}
  }

  var metadata: Border0_V1_ConnectorMetadata {
    get {
      if case .metadata(let v)? = requestType {return v}
      return Border0_V1_ConnectorMetadata()
    }
    set {requestType = .metadata(newValue)}
  }

  var authorize: Border0_V1_AuthorizeRequest {
    get {
      if case .authorize(let v)? = requestType {return v}
      return Border0_V1_AuthorizeRequest()
    }
    set {requestType = .authorize(newValue)}
  }

  var sessionUpdate: Border0_V1_SessionUpdateRequest {
    get {
      if case .sessionUpdate(let v)? = requestType {return v}
      return Border0_V1_SessionUpdateRequest()
    }
    set {requestType = .sessionUpdate(newValue)}
  }

  var sshCertificateSignRequest: Border0_V1_SshCertificateSignRequest {
    get {
      if case .sshCertificateSignRequest(let v)? = requestType {return v}
      return Border0_V1_SshCertificateSignRequest()
    }
    set {requestType = .sshCertificateSignRequest(newValue)}
  }

  var uploadRecording: Border0_V1_UploadRecording {
    get {
      if case .uploadRecording(let v)? = requestType {return v}
      return Border0_V1_UploadRecording()
    }
    set {requestType = .uploadRecording(newValue)}
  }

  var certificateSignRequest: Border0_V1_CertificateSignRequest {
    get {
      if case .certificateSignRequest(let v)? = requestType {return v}
      return Border0_V1_CertificateSignRequest()
    }
    set {requestType = .certificateSignRequest(newValue)}
  }

  var sessionEvent: Border0_V1_SessionEvent {
    get {
      if case .sessionEvent(let v)? = requestType {return v}
      return Border0_V1_SessionEvent()
    }
    set {requestType = .sessionEvent(newValue)}
  }

  var discoveryDetails: Border0_Common_V1_DiscoveryDetailsMessage {
    get {
      if case .discoveryDetails(let v)? = requestType {return v}
      return Border0_Common_V1_DiscoveryDetailsMessage()
    }
    set {requestType = .discoveryDetails(newValue)}
  }

  var authorizePeer: Border0_V1_AuthorizePeerRequest {
    get {
      if case .authorizePeer(let v)? = requestType {return v}
      return Border0_V1_AuthorizePeerRequest()
    }
    set {requestType = .authorizePeer(newValue)}
  }

  var session: Border0_V1_SessionRequest {
    get {
      if case .session(let v)? = requestType {return v}
      return Border0_V1_SessionRequest()
    }
    set {requestType = .session(newValue)}
  }

  var stats: Border0_Common_V1_StatsMessage {
    get {
      if case .stats(let v)? = requestType {return v}
      return Border0_Common_V1_StatsMessage()
    }
    set {requestType = .stats(newValue)}
  }

  var logs: Border0_V1_Logs {
    get {
      if case .logs(let v)? = requestType {return v}
      return Border0_V1_Logs()
    }
    set {requestType = .logs(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_RequestType: Equatable, Sendable {
    case config(Border0_V1_Config)
    case heartbeat(Border0_Common_V1_HeartbeatMessage)
    case pluginDiscoveryResults(Border0_V1_PluginDiscoveryResults)
    case tunnelCertificateSignRequest(Border0_V1_TunnelCertificateSignRequest)
    case log(Border0_V1_Log)
    case metadata(Border0_V1_ConnectorMetadata)
    case authorize(Border0_V1_AuthorizeRequest)
    case sessionUpdate(Border0_V1_SessionUpdateRequest)
    case sshCertificateSignRequest(Border0_V1_SshCertificateSignRequest)
    case uploadRecording(Border0_V1_UploadRecording)
    case certificateSignRequest(Border0_V1_CertificateSignRequest)
    case sessionEvent(Border0_V1_SessionEvent)
    case discoveryDetails(Border0_Common_V1_DiscoveryDetailsMessage)
    case authorizePeer(Border0_V1_AuthorizePeerRequest)
    case session(Border0_V1_SessionRequest)
    case stats(Border0_Common_V1_StatsMessage)
    case logs(Border0_V1_Logs)

  }

  init() {}
}

struct Border0_V1_ControlStreamResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestType: Border0_V1_ControlStreamResponse.OneOf_RequestType? = nil

  var init_p: Border0_V1_Init {
    get {
      if case .init_p(let v)? = requestType {return v}
      return Border0_V1_Init()
    }
    set {requestType = .init_p(newValue)}
  }

  var connectorConfig: Border0_V1_ConnectorConfig {
    get {
      if case .connectorConfig(let v)? = requestType {return v}
      return Border0_V1_ConnectorConfig()
    }
    set {requestType = .connectorConfig(newValue)}
  }

  var updateConfig: Border0_V1_UpdateConfig {
    get {
      if case .updateConfig(let v)? = requestType {return v}
      return Border0_V1_UpdateConfig()
    }
    set {requestType = .updateConfig(newValue)}
  }

  var heartbeat: Border0_Common_V1_HeartbeatMessage {
    get {
      if case .heartbeat(let v)? = requestType {return v}
      return Border0_Common_V1_HeartbeatMessage()
    }
    set {requestType = .heartbeat(newValue)}
  }

  var tunnelCertificateSignResponse: Border0_V1_TunnelCertificateSignResponse {
    get {
      if case .tunnelCertificateSignResponse(let v)? = requestType {return v}
      return Border0_V1_TunnelCertificateSignResponse()
    }
    set {requestType = .tunnelCertificateSignResponse(newValue)}
  }

  var discover: Border0_V1_Discover {
    get {
      if case .discover(let v)? = requestType {return v}
      return Border0_V1_Discover()
    }
    set {requestType = .discover(newValue)}
  }

  var stop: Border0_V1_Stop {
    get {
      if case .stop(let v)? = requestType {return v}
      return Border0_V1_Stop()
    }
    set {requestType = .stop(newValue)}
  }

  var disconnect: Border0_V1_Disconnect {
    get {
      if case .disconnect(let v)? = requestType {return v}
      return Border0_V1_Disconnect()
    }
    set {requestType = .disconnect(newValue)}
  }

  var authorize: Border0_V1_AuthorizeResponse {
    get {
      if case .authorize(let v)? = requestType {return v}
      return Border0_V1_AuthorizeResponse()
    }
    set {requestType = .authorize(newValue)}
  }

  var sshCertificateSignResponse: Border0_V1_SshCertificateSignResponse {
    get {
      if case .sshCertificateSignResponse(let v)? = requestType {return v}
      return Border0_V1_SshCertificateSignResponse()
    }
    set {requestType = .sshCertificateSignResponse(newValue)}
  }

  var certificateSignResponse: Border0_V1_CertificateSignResponse {
    get {
      if case .certificateSignResponse(let v)? = requestType {return v}
      return Border0_V1_CertificateSignResponse()
    }
    set {requestType = .certificateSignResponse(newValue)}
  }

  var networkState: Border0_Common_V1_NetworkStateMessage {
    get {
      if case .networkState(let v)? = requestType {return v}
      return Border0_Common_V1_NetworkStateMessage()
    }
    set {requestType = .networkState(newValue)}
  }

  var peerOnline: Border0_Common_V1_PeerOnlineMessage {
    get {
      if case .peerOnline(let v)? = requestType {return v}
      return Border0_Common_V1_PeerOnlineMessage()
    }
    set {requestType = .peerOnline(newValue)}
  }

  var peerOffline: Border0_Common_V1_PeerOfflineMessage {
    get {
      if case .peerOffline(let v)? = requestType {return v}
      return Border0_Common_V1_PeerOfflineMessage()
    }
    set {requestType = .peerOffline(newValue)}
  }

  var session: Border0_V1_SessionResponse {
    get {
      if case .session(let v)? = requestType {return v}
      return Border0_V1_SessionResponse()
    }
    set {requestType = .session(newValue)}
  }

  var allowedNetworks: Border0_V1_AllowedNetworks {
    get {
      if case .allowedNetworks(let v)? = requestType {return v}
      return Border0_V1_AllowedNetworks()
    }
    set {requestType = .allowedNetworks(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_RequestType: Equatable, Sendable {
    case init_p(Border0_V1_Init)
    case connectorConfig(Border0_V1_ConnectorConfig)
    case updateConfig(Border0_V1_UpdateConfig)
    case heartbeat(Border0_Common_V1_HeartbeatMessage)
    case tunnelCertificateSignResponse(Border0_V1_TunnelCertificateSignResponse)
    case discover(Border0_V1_Discover)
    case stop(Border0_V1_Stop)
    case disconnect(Border0_V1_Disconnect)
    case authorize(Border0_V1_AuthorizeResponse)
    case sshCertificateSignResponse(Border0_V1_SshCertificateSignResponse)
    case certificateSignResponse(Border0_V1_CertificateSignResponse)
    case networkState(Border0_Common_V1_NetworkStateMessage)
    case peerOnline(Border0_Common_V1_PeerOnlineMessage)
    case peerOffline(Border0_Common_V1_PeerOfflineMessage)
    case session(Border0_V1_SessionResponse)
    case allowedNetworks(Border0_V1_AllowedNetworks)

  }

  init() {}
}

struct Border0_V1_Organization: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var subdomain: String = String()

  var certificates: SwiftProtobuf.Google_Protobuf_Struct {
    get {_certificates ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_certificates = newValue}
  }
  /// Returns true if `certificates` has been explicitly set.
  var hasCertificates: Bool {self._certificates != nil}
  /// Clears the value of `certificates`. Subsequent reads from it will return its default value.
  mutating func clearCertificates() {self._certificates = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _certificates: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Border0_V1_TunnelCertificateSignRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var socketID: String = String()

  var publicKey: String = String()

  var isV2: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_TunnelCertificateSignResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var certificate: String = String()

  var hostkey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_Init: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectorConfig: Border0_V1_ConnectorConfig {
    get {_connectorConfig ?? Border0_V1_ConnectorConfig()}
    set {_connectorConfig = newValue}
  }
  /// Returns true if `connectorConfig` has been explicitly set.
  var hasConnectorConfig: Bool {self._connectorConfig != nil}
  /// Clears the value of `connectorConfig`. Subsequent reads from it will return its default value.
  mutating func clearConnectorConfig() {self._connectorConfig = nil}

  var sockets: [Border0_V1_SocketConfig] = []

  var plugins: [Border0_V1_PluginConfig] = []

  /// used only for connectors in "device mode"
  var deviceID: String = String()

  var networkCidrV4: String = String()

  var networkCidrV6: String = String()

  var selfIpv4: String = String()

  var selfIpv6: String = String()

  var networkResourcesCidrV4: String = String()

  var networkResourcesCidrV6: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _connectorConfig: Border0_V1_ConnectorConfig? = nil
}

struct Border0_V1_UpdateConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var action: Border0_V1_Action = .create

  var configType: Border0_V1_UpdateConfig.OneOf_ConfigType? = nil

  var pluginConfig: Border0_V1_PluginConfig {
    get {
      if case .pluginConfig(let v)? = configType {return v}
      return Border0_V1_PluginConfig()
    }
    set {configType = .pluginConfig(newValue)}
  }

  var socketConfig: Border0_V1_SocketConfig {
    get {
      if case .socketConfig(let v)? = configType {return v}
      return Border0_V1_SocketConfig()
    }
    set {configType = .socketConfig(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ConfigType: Equatable, Sendable {
    case pluginConfig(Border0_V1_PluginConfig)
    case socketConfig(Border0_V1_SocketConfig)

  }

  init() {}
}

struct Border0_V1_Log: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connectorID: String = String()

  var socketID: String = String()

  var pluginID: String = String()

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var severity: String = String()

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Border0_V1_Logs: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var logs: [Border0_V1_Log] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_ConnectorMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: SwiftProtobuf.Google_Protobuf_Struct {
    get {_data ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _data: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Border0_V1_Config: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var connector: Bool = false

  var sockets: Bool = false

  var plugins: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_PluginDiscoveryResults: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pluginID: String = String()

  var requestID: String = String()

  var metadata: Border0_V1_PluginDiscoveryResultsMetadata {
    get {_metadata ?? Border0_V1_PluginDiscoveryResultsMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  var hasMetadata: Bool {self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  mutating func clearMetadata() {self._metadata = nil}

  var resources: [SwiftProtobuf.Google_Protobuf_Struct] = []

  var errors: [String] = []

  var warnings: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _metadata: Border0_V1_PluginDiscoveryResultsMetadata? = nil
}

struct Border0_V1_PluginDiscoveryResultsMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var discoveryID: String = String()

  var startedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_startedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startedAt = newValue}
  }
  /// Returns true if `startedAt` has been explicitly set.
  var hasStartedAt: Bool {self._startedAt != nil}
  /// Clears the value of `startedAt`. Subsequent reads from it will return its default value.
  mutating func clearStartedAt() {self._startedAt = nil}

  var endedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_endedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endedAt = newValue}
  }
  /// Returns true if `endedAt` has been explicitly set.
  var hasEndedAt: Bool {self._endedAt != nil}
  /// Clears the value of `endedAt`. Subsequent reads from it will return its default value.
  mutating func clearEndedAt() {self._endedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct Border0_V1_Tag: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_SocketConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var type: String = String()

  var config: SwiftProtobuf.Google_Protobuf_Struct {
    get {_config ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Border0_V1_ConnectorConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var heartbeatInterval: Int32 = 0

  var organization: Border0_V1_Organization {
    get {_organization ?? Border0_V1_Organization()}
    set {_organization = newValue}
  }
  /// Returns true if `organization` has been explicitly set.
  var hasOrganization: Bool {self._organization != nil}
  /// Clears the value of `organization`. Subsequent reads from it will return its default value.
  mutating func clearOrganization() {self._organization = nil}

  var privateNetworkEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _organization: Border0_V1_Organization? = nil
}

struct Border0_V1_PluginConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var type: String = String()

  var config: SwiftProtobuf.Google_Protobuf_Struct {
    get {_config ?? SwiftProtobuf.Google_Protobuf_Struct()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  var hasConfig: Bool {self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  mutating func clearConfig() {self._config = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _config: SwiftProtobuf.Google_Protobuf_Struct? = nil
}

struct Border0_V1_Discover: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var requestID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_Stop: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_Disconnect: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reason: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_AuthorizeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var `protocol`: String = String()

  var userEmail: String = String()

  var ipAddress: String = String()

  var sessionKey: String = String()

  var socketID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_AuthorizePeerRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var `protocol`: String = String()

  var publicKey: String = String()

  var ipAddress: String = String()

  var socketID: String = String()

  /// optional, used instead of public_key for email-based authz if provided
  var userEmail: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_actionList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_Permissions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var permissions: [SwiftProtobuf.Google_Protobuf_Struct] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_infoList: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_AuthorizeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var allowedActions: Dictionary<String,Border0_V1_actionList> = [:]

  var info: Dictionary<String,Border0_V1_infoList> = [:]

  var permissions: Dictionary<String,Border0_V1_Permissions> = [:]

  var email: String = String()

  var entityUuid: String = String()

  var groups: [Border0_Common_V1_Group] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_SessionUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionKey: String = String()

  var socketID: String = String()

  var userData: String = String()

  var result: String = String()

  var authInfoFailed: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_SessionRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String {
    get {_storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  var hasStartTime: Bool {_storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  var hasEndTime: Bool {_storage._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  mutating func clearEndTime() {_uniqueStorage()._endTime = nil}

  var lastSeen: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {_storage._lastSeen ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastSeen = newValue}
  }
  /// Returns true if `lastSeen` has been explicitly set.
  var hasLastSeen: Bool {_storage._lastSeen != nil}
  /// Clears the value of `lastSeen`. Subsequent reads from it will return its default value.
  mutating func clearLastSeen() {_uniqueStorage()._lastSeen = nil}

  var email: String {
    get {_storage._email}
    set {_uniqueStorage()._email = newValue}
  }

  var logType: String {
    get {_storage._logType}
    set {_uniqueStorage()._logType = newValue}
  }

  var socketID: String {
    get {_storage._socketID}
    set {_uniqueStorage()._socketID = newValue}
  }

  var serverName: String {
    get {_storage._serverName}
    set {_uniqueStorage()._serverName = newValue}
  }

  var serverPort: String {
    get {_storage._serverPort}
    set {_uniqueStorage()._serverPort = newValue}
  }

  var clientIp: String {
    get {_storage._clientIp}
    set {_uniqueStorage()._clientIp = newValue}
  }

  var clientPort: String {
    get {_storage._clientPort}
    set {_uniqueStorage()._clientPort = newValue}
  }

  var sessionData: String {
    get {_storage._sessionData}
    set {_uniqueStorage()._sessionData = newValue}
  }

  var sessionKey: String {
    get {_storage._sessionKey}
    set {_uniqueStorage()._sessionKey = newValue}
  }

  var result: String {
    get {_storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  var authInfo: String {
    get {_storage._authInfo}
    set {_uniqueStorage()._authInfo = newValue}
  }

  var metadata: Data {
    get {_storage._metadata}
    set {_uniqueStorage()._metadata = newValue}
  }

  var entityUuid: String {
    get {_storage._entityUuid}
    set {_uniqueStorage()._entityUuid = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Border0_V1_SessionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var sessionID: String = String()

  var sshTicket: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_SessionEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionKey: String = String()

  var socketID: String = String()

  var type: String = String()

  var status: String = String()

  var metadata: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_SshCertificateSignRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var socketID: String = String()

  var sessionKey: String = String()

  var userEmail: String = String()

  var publicKey: Data = Data()

  var ticket: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_SshCertificateSignResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var certificate: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_UploadRecording: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// session identifier (unique globally)
  var sessionKey: String = String()

  /// recording identifier (unique per-session)
  var recordingID: String = String()

  /// actual recording bytes
  var recording: Data = Data()

  /// type of the recording e.g. asciinema, log, etc...
  var recordingType: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_CertificateSignRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var certificateSigningRequest: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_CertificateSignResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestID: String = String()

  var certificate: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_AllowedNetworks: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var devices: Dictionary<String,Border0_V1_AllowedNetworksSocketConfig> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_AllowedNetworksSocketConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sockets: Dictionary<String,Border0_V1_AllowedNetworksSubnets> = [:]

  /// socketID -> DNS patterns for DNS-based routing
  var dnsPatterns: Dictionary<String,Border0_V1_AllowedNetworksDnsPatterns> = [:]

  /// The device's IPv4 address (may be empty)
  var ipv4Address: String = String()

  /// The device's IPv6 address (may be empty)
  var ipv6Address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Border0_V1_AllowedNetworksSubnets: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subnets: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// DNS patterns for a socket. Supports exact domains ("api.example.com") and wildcards ("*.example.com").
/// Connectors use these patterns to resolve DNS queries and manage firewall rules automatically.
struct Border0_V1_AllowedNetworksDnsPatterns: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of DNS patterns (e.g., "*.example.com", "api.company.io")
  var patterns: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "border0.v1"

extension Border0_V1_Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CREATE\0\u{1}UPDATE\0\u{1}DELETE\0\u{1}OTHER\0")
}

extension Border0_V1_ControlStreamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ControlStreamRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}config\0\u{1}heartbeat\0\u{3}plugin_discovery_results\0\u{4}\u{2}tunnel_certificate_sign_request\0\u{1}log\0\u{1}metadata\0\u{1}authorize\0\u{3}session_update\0\u{3}ssh_certificate_sign_request\0\u{3}upload_recording\0\u{3}Certificate_sign_request\0\u{3}session_event\0\u{3}discovery_details\0\u{3}authorize_peer\0\u{1}session\0\u{1}stats\0\u{1}logs\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Border0_V1_Config?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .config(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .config(v)
        }
      }()
      case 2: try {
        var v: Border0_Common_V1_HeartbeatMessage?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .heartbeat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .heartbeat(v)
        }
      }()
      case 3: try {
        var v: Border0_V1_PluginDiscoveryResults?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .pluginDiscoveryResults(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .pluginDiscoveryResults(v)
        }
      }()
      case 5: try {
        var v: Border0_V1_TunnelCertificateSignRequest?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .tunnelCertificateSignRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .tunnelCertificateSignRequest(v)
        }
      }()
      case 6: try {
        var v: Border0_V1_Log?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .log(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .log(v)
        }
      }()
      case 7: try {
        var v: Border0_V1_ConnectorMetadata?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .metadata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .metadata(v)
        }
      }()
      case 8: try {
        var v: Border0_V1_AuthorizeRequest?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .authorize(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .authorize(v)
        }
      }()
      case 9: try {
        var v: Border0_V1_SessionUpdateRequest?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .sessionUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .sessionUpdate(v)
        }
      }()
      case 10: try {
        var v: Border0_V1_SshCertificateSignRequest?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .sshCertificateSignRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .sshCertificateSignRequest(v)
        }
      }()
      case 11: try {
        var v: Border0_V1_UploadRecording?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .uploadRecording(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .uploadRecording(v)
        }
      }()
      case 12: try {
        var v: Border0_V1_CertificateSignRequest?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .certificateSignRequest(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .certificateSignRequest(v)
        }
      }()
      case 13: try {
        var v: Border0_V1_SessionEvent?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .sessionEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .sessionEvent(v)
        }
      }()
      case 14: try {
        var v: Border0_Common_V1_DiscoveryDetailsMessage?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .discoveryDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .discoveryDetails(v)
        }
      }()
      case 15: try {
        var v: Border0_V1_AuthorizePeerRequest?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .authorizePeer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .authorizePeer(v)
        }
      }()
      case 16: try {
        var v: Border0_V1_SessionRequest?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .session(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .session(v)
        }
      }()
      case 17: try {
        var v: Border0_Common_V1_StatsMessage?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .stats(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .stats(v)
        }
      }()
      case 18: try {
        var v: Border0_V1_Logs?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .logs(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .logs(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.requestType {
    case .config?: try {
      guard case .config(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .heartbeat?: try {
      guard case .heartbeat(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .pluginDiscoveryResults?: try {
      guard case .pluginDiscoveryResults(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .tunnelCertificateSignRequest?: try {
      guard case .tunnelCertificateSignRequest(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .log?: try {
      guard case .log(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .metadata?: try {
      guard case .metadata(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .authorize?: try {
      guard case .authorize(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .sessionUpdate?: try {
      guard case .sessionUpdate(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .sshCertificateSignRequest?: try {
      guard case .sshCertificateSignRequest(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .uploadRecording?: try {
      guard case .uploadRecording(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .certificateSignRequest?: try {
      guard case .certificateSignRequest(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .sessionEvent?: try {
      guard case .sessionEvent(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .discoveryDetails?: try {
      guard case .discoveryDetails(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .authorizePeer?: try {
      guard case .authorizePeer(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .session?: try {
      guard case .session(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .stats?: try {
      guard case .stats(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .logs?: try {
      guard case .logs(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_ControlStreamRequest, rhs: Border0_V1_ControlStreamRequest) -> Bool {
    if lhs.requestType != rhs.requestType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_ControlStreamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ControlStreamResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}init\0\u{3}connector_config\0\u{3}update_config\0\u{1}heartbeat\0\u{3}tunnel_certificate_sign_response\0\u{1}discover\0\u{1}stop\0\u{1}disconnect\0\u{1}authorize\0\u{3}ssh_certificate_sign_response\0\u{3}Certificate_sign_response\0\u{3}network_state\0\u{3}peer_online\0\u{3}peer_offline\0\u{2}\u{2}session\0\u{3}allowed_networks\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Border0_V1_Init?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .init_p(v)
        }
      }()
      case 2: try {
        var v: Border0_V1_ConnectorConfig?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .connectorConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .connectorConfig(v)
        }
      }()
      case 3: try {
        var v: Border0_V1_UpdateConfig?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .updateConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .updateConfig(v)
        }
      }()
      case 4: try {
        var v: Border0_Common_V1_HeartbeatMessage?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .heartbeat(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .heartbeat(v)
        }
      }()
      case 5: try {
        var v: Border0_V1_TunnelCertificateSignResponse?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .tunnelCertificateSignResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .tunnelCertificateSignResponse(v)
        }
      }()
      case 6: try {
        var v: Border0_V1_Discover?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .discover(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .discover(v)
        }
      }()
      case 7: try {
        var v: Border0_V1_Stop?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .stop(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .stop(v)
        }
      }()
      case 8: try {
        var v: Border0_V1_Disconnect?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .disconnect(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .disconnect(v)
        }
      }()
      case 9: try {
        var v: Border0_V1_AuthorizeResponse?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .authorize(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .authorize(v)
        }
      }()
      case 10: try {
        var v: Border0_V1_SshCertificateSignResponse?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .sshCertificateSignResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .sshCertificateSignResponse(v)
        }
      }()
      case 11: try {
        var v: Border0_V1_CertificateSignResponse?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .certificateSignResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .certificateSignResponse(v)
        }
      }()
      case 12: try {
        var v: Border0_Common_V1_NetworkStateMessage?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .networkState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .networkState(v)
        }
      }()
      case 13: try {
        var v: Border0_Common_V1_PeerOnlineMessage?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .peerOnline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .peerOnline(v)
        }
      }()
      case 14: try {
        var v: Border0_Common_V1_PeerOfflineMessage?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .peerOffline(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .peerOffline(v)
        }
      }()
      case 16: try {
        var v: Border0_V1_SessionResponse?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .session(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .session(v)
        }
      }()
      case 17: try {
        var v: Border0_V1_AllowedNetworks?
        var hadOneofValue = false
        if let current = self.requestType {
          hadOneofValue = true
          if case .allowedNetworks(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.requestType = .allowedNetworks(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.requestType {
    case .init_p?: try {
      guard case .init_p(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .connectorConfig?: try {
      guard case .connectorConfig(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateConfig?: try {
      guard case .updateConfig(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .heartbeat?: try {
      guard case .heartbeat(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .tunnelCertificateSignResponse?: try {
      guard case .tunnelCertificateSignResponse(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .discover?: try {
      guard case .discover(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .stop?: try {
      guard case .stop(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .disconnect?: try {
      guard case .disconnect(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .authorize?: try {
      guard case .authorize(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .sshCertificateSignResponse?: try {
      guard case .sshCertificateSignResponse(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .certificateSignResponse?: try {
      guard case .certificateSignResponse(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .networkState?: try {
      guard case .networkState(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .peerOnline?: try {
      guard case .peerOnline(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .peerOffline?: try {
      guard case .peerOffline(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .session?: try {
      guard case .session(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .allowedNetworks?: try {
      guard case .allowedNetworks(let v)? = self.requestType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_ControlStreamResponse, rhs: Border0_V1_ControlStreamResponse) -> Bool {
    if lhs.requestType != rhs.requestType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Organization: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Organization"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}subdomain\0\u{1}certificates\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subdomain) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._certificates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.subdomain.isEmpty {
      try visitor.visitSingularStringField(value: self.subdomain, fieldNumber: 3)
    }
    try { if let v = self._certificates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Organization, rhs: Border0_V1_Organization) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.subdomain != rhs.subdomain {return false}
    if lhs._certificates != rhs._certificates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_TunnelCertificateSignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TunnelCertificateSignRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{3}socket_id\0\u{3}public_key\0\u{3}is_v2\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.socketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isV2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.socketID.isEmpty {
      try visitor.visitSingularStringField(value: self.socketID, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    if self.isV2 != false {
      try visitor.visitSingularBoolField(value: self.isV2, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_TunnelCertificateSignRequest, rhs: Border0_V1_TunnelCertificateSignRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.socketID != rhs.socketID {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.isV2 != rhs.isV2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_TunnelCertificateSignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TunnelCertificateSignResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{1}certificate\0\u{1}hostkey\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.certificate) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hostkey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.certificate.isEmpty {
      try visitor.visitSingularStringField(value: self.certificate, fieldNumber: 2)
    }
    if !self.hostkey.isEmpty {
      try visitor.visitSingularStringField(value: self.hostkey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_TunnelCertificateSignResponse, rhs: Border0_V1_TunnelCertificateSignResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.certificate != rhs.certificate {return false}
    if lhs.hostkey != rhs.hostkey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Init: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Init"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connector_config\0\u{1}sockets\0\u{1}plugins\0\u{3}device_id\0\u{3}network_cidr_v4\0\u{3}network_cidr_v6\0\u{3}self_ipv4\0\u{3}self_ipv6\0\u{3}network_resources_cidr_v4\0\u{3}network_resources_cidr_v6\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connectorConfig) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.sockets) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.plugins) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.networkCidrV4) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.networkCidrV6) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.selfIpv4) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.selfIpv6) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.networkResourcesCidrV4) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.networkResourcesCidrV6) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connectorConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.sockets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sockets, fieldNumber: 2)
    }
    if !self.plugins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.plugins, fieldNumber: 3)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 4)
    }
    if !self.networkCidrV4.isEmpty {
      try visitor.visitSingularStringField(value: self.networkCidrV4, fieldNumber: 5)
    }
    if !self.networkCidrV6.isEmpty {
      try visitor.visitSingularStringField(value: self.networkCidrV6, fieldNumber: 6)
    }
    if !self.selfIpv4.isEmpty {
      try visitor.visitSingularStringField(value: self.selfIpv4, fieldNumber: 7)
    }
    if !self.selfIpv6.isEmpty {
      try visitor.visitSingularStringField(value: self.selfIpv6, fieldNumber: 8)
    }
    if !self.networkResourcesCidrV4.isEmpty {
      try visitor.visitSingularStringField(value: self.networkResourcesCidrV4, fieldNumber: 9)
    }
    if !self.networkResourcesCidrV6.isEmpty {
      try visitor.visitSingularStringField(value: self.networkResourcesCidrV6, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Init, rhs: Border0_V1_Init) -> Bool {
    if lhs._connectorConfig != rhs._connectorConfig {return false}
    if lhs.sockets != rhs.sockets {return false}
    if lhs.plugins != rhs.plugins {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.networkCidrV4 != rhs.networkCidrV4 {return false}
    if lhs.networkCidrV6 != rhs.networkCidrV6 {return false}
    if lhs.selfIpv4 != rhs.selfIpv4 {return false}
    if lhs.selfIpv6 != rhs.selfIpv6 {return false}
    if lhs.networkResourcesCidrV4 != rhs.networkResourcesCidrV4 {return false}
    if lhs.networkResourcesCidrV6 != rhs.networkResourcesCidrV6 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_UpdateConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}action\0\u{3}plugin_config\0\u{3}socket_config\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 2: try {
        var v: Border0_V1_PluginConfig?
        var hadOneofValue = false
        if let current = self.configType {
          hadOneofValue = true
          if case .pluginConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.configType = .pluginConfig(v)
        }
      }()
      case 3: try {
        var v: Border0_V1_SocketConfig?
        var hadOneofValue = false
        if let current = self.configType {
          hadOneofValue = true
          if case .socketConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.configType = .socketConfig(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.action != .create {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 1)
    }
    switch self.configType {
    case .pluginConfig?: try {
      guard case .pluginConfig(let v)? = self.configType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .socketConfig?: try {
      guard case .socketConfig(let v)? = self.configType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_UpdateConfig, rhs: Border0_V1_UpdateConfig) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.configType != rhs.configType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Log"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connector_id\0\u{3}socket_id\0\u{3}plugin_id\0\u{1}timestamp\0\u{1}severity\0\u{1}message\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.socketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pluginID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.severity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.connectorID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectorID, fieldNumber: 1)
    }
    if !self.socketID.isEmpty {
      try visitor.visitSingularStringField(value: self.socketID, fieldNumber: 2)
    }
    if !self.pluginID.isEmpty {
      try visitor.visitSingularStringField(value: self.pluginID, fieldNumber: 3)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.severity.isEmpty {
      try visitor.visitSingularStringField(value: self.severity, fieldNumber: 5)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Log, rhs: Border0_V1_Log) -> Bool {
    if lhs.connectorID != rhs.connectorID {return false}
    if lhs.socketID != rhs.socketID {return false}
    if lhs.pluginID != rhs.pluginID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.severity != rhs.severity {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Logs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Logs"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}logs\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.logs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.logs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.logs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Logs, rhs: Border0_V1_Logs) -> Bool {
    if lhs.logs != rhs.logs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_ConnectorMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectorMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_ConnectorMetadata, rhs: Border0_V1_ConnectorMetadata) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Config: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Config"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}connector\0\u{1}sockets\0\u{1}plugins\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.connector) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.sockets) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.plugins) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.connector != false {
      try visitor.visitSingularBoolField(value: self.connector, fieldNumber: 1)
    }
    if self.sockets != false {
      try visitor.visitSingularBoolField(value: self.sockets, fieldNumber: 2)
    }
    if self.plugins != false {
      try visitor.visitSingularBoolField(value: self.plugins, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Config, rhs: Border0_V1_Config) -> Bool {
    if lhs.connector != rhs.connector {return false}
    if lhs.sockets != rhs.sockets {return false}
    if lhs.plugins != rhs.plugins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_PluginDiscoveryResults: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDiscoveryResults"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}plugin_id\0\u{3}request_id\0\u{1}metadata\0\u{1}resources\0\u{1}errors\0\u{1}warnings\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pluginID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.resources) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.errors) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.warnings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pluginID.isEmpty {
      try visitor.visitSingularStringField(value: self.pluginID, fieldNumber: 1)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 2)
    }
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.resources.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.resources, fieldNumber: 4)
    }
    if !self.errors.isEmpty {
      try visitor.visitRepeatedStringField(value: self.errors, fieldNumber: 5)
    }
    if !self.warnings.isEmpty {
      try visitor.visitRepeatedStringField(value: self.warnings, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_PluginDiscoveryResults, rhs: Border0_V1_PluginDiscoveryResults) -> Bool {
    if lhs.pluginID != rhs.pluginID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.resources != rhs.resources {return false}
    if lhs.errors != rhs.errors {return false}
    if lhs.warnings != rhs.warnings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_PluginDiscoveryResultsMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDiscoveryResultsMetadata"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}discovery_id\0\u{3}started_at\0\u{3}ended_at\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.discoveryID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startedAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._endedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.discoveryID.isEmpty {
      try visitor.visitSingularStringField(value: self.discoveryID, fieldNumber: 1)
    }
    try { if let v = self._startedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_PluginDiscoveryResultsMetadata, rhs: Border0_V1_PluginDiscoveryResultsMetadata) -> Bool {
    if lhs.discoveryID != rhs.discoveryID {return false}
    if lhs._startedAt != rhs._startedAt {return false}
    if lhs._endedAt != rhs._endedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Tag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tag"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Tag, rhs: Border0_V1_Tag) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_SocketConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SocketConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}type\0\u{1}config\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_SocketConfig, rhs: Border0_V1_SocketConfig) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_ConnectorConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConnectorConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}heartbeat_interval\0\u{1}organization\0\u{3}private_network_enabled\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.heartbeatInterval) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._organization) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.privateNetworkEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.heartbeatInterval != 0 {
      try visitor.visitSingularInt32Field(value: self.heartbeatInterval, fieldNumber: 2)
    }
    try { if let v = self._organization {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.privateNetworkEnabled != false {
      try visitor.visitSingularBoolField(value: self.privateNetworkEnabled, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_ConnectorConfig, rhs: Border0_V1_ConnectorConfig) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.heartbeatInterval != rhs.heartbeatInterval {return false}
    if lhs._organization != rhs._organization {return false}
    if lhs.privateNetworkEnabled != rhs.privateNetworkEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_PluginConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}name\0\u{1}type\0\u{1}config\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_PluginConfig, rhs: Border0_V1_PluginConfig) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Discover: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Discover"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}request_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Discover, rhs: Border0_V1_Discover) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Stop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Stop"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Stop, rhs: Border0_V1_Stop) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Disconnect: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Disconnect"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Disconnect, rhs: Border0_V1_Disconnect) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_AuthorizeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizeRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{1}protocol\0\u{3}user_email\0\u{3}ip_address\0\u{3}session_key\0\u{3}socket_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userEmail) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sessionKey) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.socketID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 2)
    }
    if !self.userEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmail, fieldNumber: 3)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 4)
    }
    if !self.sessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionKey, fieldNumber: 5)
    }
    if !self.socketID.isEmpty {
      try visitor.visitSingularStringField(value: self.socketID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_AuthorizeRequest, rhs: Border0_V1_AuthorizeRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.userEmail != rhs.userEmail {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.sessionKey != rhs.sessionKey {return false}
    if lhs.socketID != rhs.socketID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_AuthorizePeerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizePeerRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{1}protocol\0\u{3}public_key\0\u{3}ip_address\0\u{3}socket_id\0\u{3}user_email\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.`protocol`) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipAddress) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.socketID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.userEmail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.`protocol`.isEmpty {
      try visitor.visitSingularStringField(value: self.`protocol`, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    if !self.ipAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ipAddress, fieldNumber: 4)
    }
    if !self.socketID.isEmpty {
      try visitor.visitSingularStringField(value: self.socketID, fieldNumber: 5)
    }
    if !self.userEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmail, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_AuthorizePeerRequest, rhs: Border0_V1_AuthorizePeerRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.`protocol` != rhs.`protocol` {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.ipAddress != rhs.ipAddress {return false}
    if lhs.socketID != rhs.socketID {return false}
    if lhs.userEmail != rhs.userEmail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_actionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".actionList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_actionList, rhs: Border0_V1_actionList) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_Permissions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Permissions"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}permissions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.permissions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.permissions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_Permissions, rhs: Border0_V1_Permissions) -> Bool {
    if lhs.permissions != rhs.permissions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_infoList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".infoList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_infoList, rhs: Border0_V1_infoList) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_AuthorizeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthorizeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{3}allowed_actions\0\u{1}info\0\u{2}\u{2}permissions\0\u{1}email\0\u{3}entity_uuid\0\u{1}groups\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_actionList>.self, value: &self.allowedActions) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_infoList>.self, value: &self.info) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_Permissions>.self, value: &self.permissions) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.entityUuid) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.allowedActions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_actionList>.self, value: self.allowedActions, fieldNumber: 2)
    }
    if !self.info.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_infoList>.self, value: self.info, fieldNumber: 3)
    }
    if !self.permissions.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_Permissions>.self, value: self.permissions, fieldNumber: 5)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 6)
    }
    if !self.entityUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.entityUuid, fieldNumber: 7)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_AuthorizeResponse, rhs: Border0_V1_AuthorizeResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.allowedActions != rhs.allowedActions {return false}
    if lhs.info != rhs.info {return false}
    if lhs.permissions != rhs.permissions {return false}
    if lhs.email != rhs.email {return false}
    if lhs.entityUuid != rhs.entityUuid {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_SessionUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionUpdateRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_key\0\u{3}socket_id\0\u{3}user_data\0\u{1}result\0\u{3}auth_info_failed\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.socketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userData) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.result) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.authInfoFailed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionKey, fieldNumber: 1)
    }
    if !self.socketID.isEmpty {
      try visitor.visitSingularStringField(value: self.socketID, fieldNumber: 2)
    }
    if !self.userData.isEmpty {
      try visitor.visitSingularStringField(value: self.userData, fieldNumber: 3)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 4)
    }
    if !self.authInfoFailed.isEmpty {
      try visitor.visitSingularStringField(value: self.authInfoFailed, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_SessionUpdateRequest, rhs: Border0_V1_SessionUpdateRequest) -> Bool {
    if lhs.sessionKey != rhs.sessionKey {return false}
    if lhs.socketID != rhs.socketID {return false}
    if lhs.userData != rhs.userData {return false}
    if lhs.result != rhs.result {return false}
    if lhs.authInfoFailed != rhs.authInfoFailed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_SessionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{3}start_time\0\u{3}end_time\0\u{3}last_seen\0\u{1}email\0\u{3}log_type\0\u{3}socket_id\0\u{3}server_name\0\u{3}server_port\0\u{3}client_ip\0\u{3}client_port\0\u{3}session_data\0\u{3}session_key\0\u{1}result\0\u{3}auth_info\0\u{1}metadata\0\u{3}entity_uuid\0")

  fileprivate class _StorageClass {
    var _requestID: String = String()
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastSeen: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _email: String = String()
    var _logType: String = String()
    var _socketID: String = String()
    var _serverName: String = String()
    var _serverPort: String = String()
    var _clientIp: String = String()
    var _clientPort: String = String()
    var _sessionData: String = String()
    var _sessionKey: String = String()
    var _result: String = String()
    var _authInfo: String = String()
    var _metadata: Data = Data()
    var _entityUuid: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _requestID = source._requestID
      _startTime = source._startTime
      _endTime = source._endTime
      _lastSeen = source._lastSeen
      _email = source._email
      _logType = source._logType
      _socketID = source._socketID
      _serverName = source._serverName
      _serverPort = source._serverPort
      _clientIp = source._clientIp
      _clientPort = source._clientPort
      _sessionData = source._sessionData
      _sessionKey = source._sessionKey
      _result = source._result
      _authInfo = source._authInfo
      _metadata = source._metadata
      _entityUuid = source._entityUuid
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._endTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lastSeen) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._email) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._logType) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._socketID) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._serverName) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._serverPort) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._clientIp) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._clientPort) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._sessionData) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._sessionKey) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._result) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._authInfo) }()
        case 16: try { try decoder.decodeSingularBytesField(value: &_storage._metadata) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._entityUuid) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 1)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._endTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._lastSeen {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._email.isEmpty {
        try visitor.visitSingularStringField(value: _storage._email, fieldNumber: 5)
      }
      if !_storage._logType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._logType, fieldNumber: 6)
      }
      if !_storage._socketID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._socketID, fieldNumber: 7)
      }
      if !_storage._serverName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverName, fieldNumber: 8)
      }
      if !_storage._serverPort.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverPort, fieldNumber: 9)
      }
      if !_storage._clientIp.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientIp, fieldNumber: 10)
      }
      if !_storage._clientPort.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientPort, fieldNumber: 11)
      }
      if !_storage._sessionData.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionData, fieldNumber: 12)
      }
      if !_storage._sessionKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sessionKey, fieldNumber: 13)
      }
      if !_storage._result.isEmpty {
        try visitor.visitSingularStringField(value: _storage._result, fieldNumber: 14)
      }
      if !_storage._authInfo.isEmpty {
        try visitor.visitSingularStringField(value: _storage._authInfo, fieldNumber: 15)
      }
      if !_storage._metadata.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._metadata, fieldNumber: 16)
      }
      if !_storage._entityUuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._entityUuid, fieldNumber: 17)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_SessionRequest, rhs: Border0_V1_SessionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._endTime != rhs_storage._endTime {return false}
        if _storage._lastSeen != rhs_storage._lastSeen {return false}
        if _storage._email != rhs_storage._email {return false}
        if _storage._logType != rhs_storage._logType {return false}
        if _storage._socketID != rhs_storage._socketID {return false}
        if _storage._serverName != rhs_storage._serverName {return false}
        if _storage._serverPort != rhs_storage._serverPort {return false}
        if _storage._clientIp != rhs_storage._clientIp {return false}
        if _storage._clientPort != rhs_storage._clientPort {return false}
        if _storage._sessionData != rhs_storage._sessionData {return false}
        if _storage._sessionKey != rhs_storage._sessionKey {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._authInfo != rhs_storage._authInfo {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        if _storage._entityUuid != rhs_storage._entityUuid {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_SessionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{3}session_id\0\u{3}ssh_ticket\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.sshTicket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 2)
    }
    if !self.sshTicket.isEmpty {
      try visitor.visitSingularBytesField(value: self.sshTicket, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_SessionResponse, rhs: Border0_V1_SessionResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.sshTicket != rhs.sshTicket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_SessionEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SessionEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_key\0\u{3}socket_id\0\u{1}type\0\u{1}status\0\u{1}metadata\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.socketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.status) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.metadata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionKey, fieldNumber: 1)
    }
    if !self.socketID.isEmpty {
      try visitor.visitSingularStringField(value: self.socketID, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    if !self.status.isEmpty {
      try visitor.visitSingularStringField(value: self.status, fieldNumber: 4)
    }
    if !self.metadata.isEmpty {
      try visitor.visitSingularStringField(value: self.metadata, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_SessionEvent, rhs: Border0_V1_SessionEvent) -> Bool {
    if lhs.sessionKey != rhs.sessionKey {return false}
    if lhs.socketID != rhs.socketID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.status != rhs.status {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_SshCertificateSignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SshCertificateSignRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{3}socket_id\0\u{3}session_key\0\u{3}user_email\0\u{3}public_key\0\u{1}ticket\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.socketID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sessionKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.userEmail) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.ticket) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.socketID.isEmpty {
      try visitor.visitSingularStringField(value: self.socketID, fieldNumber: 2)
    }
    if !self.sessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionKey, fieldNumber: 3)
    }
    if !self.userEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.userEmail, fieldNumber: 4)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 5)
    }
    if !self.ticket.isEmpty {
      try visitor.visitSingularBytesField(value: self.ticket, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_SshCertificateSignRequest, rhs: Border0_V1_SshCertificateSignRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.socketID != rhs.socketID {return false}
    if lhs.sessionKey != rhs.sessionKey {return false}
    if lhs.userEmail != rhs.userEmail {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.ticket != rhs.ticket {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_SshCertificateSignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SshCertificateSignResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{1}certificate\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.certificate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.certificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.certificate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_SshCertificateSignResponse, rhs: Border0_V1_SshCertificateSignResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.certificate != rhs.certificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_UploadRecording: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UploadRecording"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_key\0\u{3}recording_id\0\u{1}recording\0\u{3}recording_type\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.recordingID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.recording) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.recordingType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionKey.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionKey, fieldNumber: 1)
    }
    if !self.recordingID.isEmpty {
      try visitor.visitSingularStringField(value: self.recordingID, fieldNumber: 2)
    }
    if !self.recording.isEmpty {
      try visitor.visitSingularBytesField(value: self.recording, fieldNumber: 3)
    }
    if !self.recordingType.isEmpty {
      try visitor.visitSingularStringField(value: self.recordingType, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_UploadRecording, rhs: Border0_V1_UploadRecording) -> Bool {
    if lhs.sessionKey != rhs.sessionKey {return false}
    if lhs.recordingID != rhs.recordingID {return false}
    if lhs.recording != rhs.recording {return false}
    if lhs.recordingType != rhs.recordingType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_CertificateSignRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateSignRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{3}certificate_signing_request\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.certificateSigningRequest) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.certificateSigningRequest.isEmpty {
      try visitor.visitSingularBytesField(value: self.certificateSigningRequest, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_CertificateSignRequest, rhs: Border0_V1_CertificateSignRequest) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.certificateSigningRequest != rhs.certificateSigningRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_CertificateSignResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CertificateSignResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{1}certificate\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.certificate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.certificate.isEmpty {
      try visitor.visitSingularBytesField(value: self.certificate, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_CertificateSignResponse, rhs: Border0_V1_CertificateSignResponse) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.certificate != rhs.certificate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_AllowedNetworks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedNetworks"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}devices\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_AllowedNetworksSocketConfig>.self, value: &self.devices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.devices.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_AllowedNetworksSocketConfig>.self, value: self.devices, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_AllowedNetworks, rhs: Border0_V1_AllowedNetworks) -> Bool {
    if lhs.devices != rhs.devices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_AllowedNetworksSocketConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedNetworksSocketConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sockets\0\u{3}dns_patterns\0\u{3}ipv4_address\0\u{3}ipv6_address\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_AllowedNetworksSubnets>.self, value: &self.sockets) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_AllowedNetworksDnsPatterns>.self, value: &self.dnsPatterns) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ipv4Address) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ipv6Address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sockets.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_AllowedNetworksSubnets>.self, value: self.sockets, fieldNumber: 1)
    }
    if !self.dnsPatterns.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Border0_V1_AllowedNetworksDnsPatterns>.self, value: self.dnsPatterns, fieldNumber: 2)
    }
    if !self.ipv4Address.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv4Address, fieldNumber: 3)
    }
    if !self.ipv6Address.isEmpty {
      try visitor.visitSingularStringField(value: self.ipv6Address, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_AllowedNetworksSocketConfig, rhs: Border0_V1_AllowedNetworksSocketConfig) -> Bool {
    if lhs.sockets != rhs.sockets {return false}
    if lhs.dnsPatterns != rhs.dnsPatterns {return false}
    if lhs.ipv4Address != rhs.ipv4Address {return false}
    if lhs.ipv6Address != rhs.ipv6Address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_AllowedNetworksSubnets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedNetworksSubnets"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}subnets\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.subnets) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.subnets.isEmpty {
      try visitor.visitRepeatedStringField(value: self.subnets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_AllowedNetworksSubnets, rhs: Border0_V1_AllowedNetworksSubnets) -> Bool {
    if lhs.subnets != rhs.subnets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Border0_V1_AllowedNetworksDnsPatterns: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllowedNetworksDnsPatterns"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}patterns\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.patterns) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patterns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.patterns, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Border0_V1_AllowedNetworksDnsPatterns, rhs: Border0_V1_AllowedNetworksDnsPatterns) -> Bool {
    if lhs.patterns != rhs.patterns {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
